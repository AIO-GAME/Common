/*|============================================|*|
|*|Author:        |*|XiNan                     |*|
|*|Date:          |*|2022-05-10                |*|
|*|E-Mail:        |*|1398581458@qq.com         |*|
|*|=============================================*/


namespace AIO.Core.Runtime
{
    /// <summary>
    /// Threader 扩展类
    /// </summary>
    public static class Threader
    {
        /*
        C#中,Thread类有一个IsBackground 的属性.MSDN上对它的解释是:获取或设置一个值，该值指示某个线程是否为后台线程。
        .Net中的线程,可以分为后台线程和前台线程。后台线程与前台线程并没有本质的区别，
        它们之间唯一的区别就是:后台线程不会防止应用程序的进程被终止掉。
        就是当前台线程都结束了的时候,整个程序也就结束了,即使还有后台线程正在运行,
        此时,所有剩余的后台线程都会被停止且不会完成.但是,只要还有一个前台线程没有结束,
        那么它将阻止程序结束.应用程序进程的存亡由前台线程决定而于后台线程无关.这就是它们的区别.
        改变线程从前台到后台不会以任何方式改变它在CPU协调程序中的优先级和状态。
        因为前台后线程与程序进程的优先级无关.下面的代码示例对比了前台线程与后台线程的行为。
        创建一个前台线程和一个后台线程。前台线程使进程保持运行，直到它完成它的 while 循环。
        前台线程完成后，进程在后台线程完成它的 while 循环之前终止。
        */

        /*
        线程池可以看做容纳线程的容器；
        一个应用程序最多只能有一个线程池；
        ThreadPool静态类通过QueueUserWorkItem()方法将工作函数排入线程池；
        每排入一个工作函数，就相当于请求创建一个线程；

        线程池的作用：
        线程池是为突然大量爆发的线程设计的，通过有限的几个固定线程为大量的操作服务，减少了创建和销毁线程所需的时间，从而提高效率。
        如果一个线程的时间非常长，就没必要用线程池了(不是不能作长时间操作，而是不宜。)，况且我们还不能控制线程池中线程的开始、挂起、和中止。
        */

    }

}

<#@ template language="C#" visibility="public" hostspecific="True"
#><#@ assembly name="System.Core"
#><#@ import namespace="System.Collections.Generic"
#><#@ import namespace="System.Linq"
#><#@ include file="Manager.ttinclude"
#><#
    var NUMBER = new Dictionary<string, string>
    {
        ["NBool"] = "bool",
        ["NSByte"] = "sbyte",
        ["NShort"] = "short",
        ["NInt"] = "int",
        ["NLong"] = "long",
        ["NByte"] = "byte",
        ["NUShort"] = "ushort",
        ["NUInt"] = "uint",
        ["NULong"] = "ulong",
        ["NChar"] = "char",
        ["NString"] = "string",
        ["NFloat"] = "float",
        ["NDouble"] = "double",
        ["NDecimal"] = "decimal",
    };

    var TO = new Dictionary<string, IList<string>> // Value to Key
    {
        ["NChar"] = new List<string>
        {
            "char",
            "byte",
            "ushort"
        },
        ["NShort"] = new List<string>
        {
            "byte",
            "sbyte",
            "char",
        },
        ["NInt"] = new List<string>
        {
            "byte",
            "sbyte",
            "char",
            "short",
            "ushort",
        },
        ["NLong"] = new List<string>
        {
            "byte",
            "sbyte",
            "char",
            "short",
            "ushort",
            "int",
            "uint"
        },
        ["NUShort"] = new List<string>
        {
            "byte",
            "char",
        },
        ["NUInt"] = new List<string>
        {
            "byte",
            "char",
            "ushort",
        },
        ["NULong"] = new List<string>
        {
            "byte",
            "char",
            "ushort",
            "uint",
        },
        ["NFloat"] = new List<string>
        {
            "byte",
            "short",
            "ushort",
            "int",
            "uint",
            "long",
            "ulong",
        },
        ["NDouble"] = new List<string>
        {
            "byte",
            "short",
            "ushort",
            "int",
            "uint",
            "long",
            "ulong",
            "float",
        },
        ["NDecimal"] = new List<string>
        {
            "byte",
            "short",
            "ushort",
            "int",
            "uint",
            "long",
            "ulong",
            "float",
            "double",
        },
    };

    var FORM = new Dictionary<string, IList<string>> // Key to Value
    {
        ["NChar"] = new List<string>
        {
            "long",
            "int",
            "uint",
            "ulong",
        },
        ["NInt"] = new List<string>
        {
            "char",
            "long",
        },
    };

    foreach (var key in TO.Keys.ToArray())
    {
        var count = TO[key].Count;
        if (count <= 0) continue;
        for (var i = 0; i < count; i++)
        {
            var type = TO[key][i];
            if (string.IsNullOrEmpty(type)) continue;
            foreach (var pair in NUMBER.Where(pair => pair.Value == type))
            {
                TO[key].Add(pair.Key);
                break;
            }
        }
    }

    foreach (var key in FORM.Keys.ToArray())
    {
        var count = FORM[key].Count;
        if (count == 0) continue;
        for (var i = 0; i < count; i++)
        {
            var type = FORM[key][i];
            if (string.IsNullOrEmpty(type)) continue;
            foreach (var pair in NUMBER.Where(pair => pair.Value == type))
            {
                FORM[key].Add(pair.Key);
                break;
            }
        }
    }

    var manager = new Manager(Host, GenerationEnvironment, "Security");
    manager.OutputPath = Path.GetDirectoryName(Host.TemplateFile);
    manager.StartHeader();
 #>
// <auto-generated> This code was generated by a tool. </auto-generated>
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.

using System;
using System.Runtime.InteropServices;
<#
    manager.EndHeader();
    foreach (var pair in NUMBER)
    {
        manager.StartBlockTemplateName($"{pair.Key}.Implicit.cs", $"{pair.Key}.cs");
#>

namespace AIO.Security
{
    [Serializable, ComVisible(true)]
    partial struct <#= pair.Key #>
    {
        /// <param name="value"> <see cref="<#= pair.Value #>"/> </param>
        public static implicit operator <#= pair.Key #>(<#= pair.Value #> value) => new <#= pair.Key #>(value);

        /// <param name="value"> <see cref="<#= pair.Key #>"/> </param>
        public static implicit operator <#= pair.Value #>(<#= pair.Key #> value) => value.Value;
<# 
        if (FORM.TryGetValue(pair.Key, out var fValue))
        {
            foreach (var item in fValue.Distinct())
            {
                if (item == pair.Value || item == pair.Key) continue;
                if (NUMBER.ContainsKey(item))
                {
#>
        /// <param name="value"> <see cref="<#= item #>"/> </param>
        public static implicit operator <#= item #>(<#= pair.Key #> value) => new <#= item #>(value.Value);
<#
                } 
                else 
                {
#> 
        /// <param name="value"> <see cref="<#= pair.Key #>"/> </param>
        public static implicit operator <#= item #>(<#= pair.Key #> value) => (<#= item #>)value.Value;
<#
                }
            }
        }
        if (TO.TryGetValue(pair.Key, out var tValue))
        {
            foreach (var item in tValue.Distinct())
            {
                if (item == pair.Value || item == pair.Key) continue;
#>      
        /// <param name="value"> <see cref="<#= item #>"/> </param>
        public static implicit operator <#= pair.Key #>(<#= item #> value) => new <#= pair.Key #>(value);
<#
            } 
        }
#>
    }
}
<#
        manager.EndBlock();
    }
    manager.Process();
#>
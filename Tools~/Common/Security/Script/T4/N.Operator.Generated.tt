<#@ template language="C#" visibility="public" hostspecific="True"
#><#@ assembly name="System.Core"
#><#@ import namespace="System.Collections.Generic"
#><#@ import namespace="System.Linq"
#><#@ include file="Manager.ttinclude"
#><#
    var NUMBER = new List<Tuple<string, string>>
    {
        new("NInt", "int"),
        new("NLong", "long"),
        new("NShort", "short"),
        new("NUInt", "uint"),
        new("NULong", "ulong"),
        new("NUShort", "ushort"),
        new("NBool", "bool"),
        new("NByte", "byte"),
        new("NChar", "char"),
        new("NSByte", "sbyte"),
        new("NString", "string"),
        new("NFloat", "float"),
        new("NDouble", "double"),
        new("NDecimal", "decimal"),
    };
    var FLOAT = new Dictionary<string, string>
    {
        ["NFloat"] = "float.Epsilon",
        ["NDouble"] = "double.Epsilon",
        ["NDecimal"] = "decimal.Zero",
    };

    var ADD_SUB = new Dictionary<string, string>
    {
        ["NChar"] = "char",
        ["NInt"] = "int",
        ["NLong"] = "long",
        ["NShort"] = "short",
        ["NUInt"] = "uint",
        ["NULong"] = "ulong",
        ["NUShort"] = "ushort",
        ["NByte"] = "byte",
        ["NSByte"] = "sbyte",
        ["NFloat"] = "float",
        ["NDouble"] = "double",
        ["NDecimal"] = "decimal",
    };
    
    var projectDirectory = Path.GetDirectoryName(Host.TemplateFile);
    var projectFilePath = string.Empty;
    while (!string.IsNullOrEmpty(projectDirectory))
    {
        projectFilePath = Directory.GetFiles(projectDirectory, "*.csproj").FirstOrDefault();
        if (projectFilePath != null) break;
        projectDirectory = Directory.GetParent(projectDirectory)?.FullName;
    }
    
    var manager = new Manager(Host, GenerationEnvironment, "Security");
    manager.OutputPath = Path.Combine(projectDirectory, "Script", "Data");
    manager.StartHeader();
 #>
// <auto-generated> This code was generated by a tool. </auto-generated>
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.

using System;
<#
    manager.EndHeader();
    foreach (var pair in NUMBER)
    {
        manager.StartBlockTemplateName($"{pair.Item1}.Operator.cs", $"{pair.Item1}.cs");
#>

namespace AIO.Security
{
    partial struct <#= pair.Item1 #>
    { 
<#
        if (!FLOAT.ContainsKey(pair.Item1))
        {
#>
        /// <param name="a"> <see cref="<#= pair.Item1 #>"/> </param>
        /// <param name="b"> <see cref="<#= pair.Item1 #>"/> </param>
        public static bool operator ==(<#= pair.Item1 #> a, <#= pair.Item1 #> b) => a.Value == b.Value;

        /// <param name="a"> <see cref="<#= pair.Item1 #>"/> </param>
        /// <param name="b"> <see cref="<#= pair.Item2 #>"/> </param>
        public static bool operator ==(<#= pair.Item1 #> a, <#= pair.Item2 #> b) => a.Value == b;

        /// <param name="a"> <see cref="<#= pair.Item1 #>"/> </param>
        /// <param name="b"> <see cref="<#= pair.Item1 #>"/> </param>
        public static bool operator !=(<#= pair.Item1 #> a, <#= pair.Item1 #> b) => a.Value != b.Value;

        /// <param name="a"> <see cref="<#= pair.Item1 #>"/> </param>
        /// <param name="b"> <see cref="<#= pair.Item2 #>"/> </param>
        public static bool operator !=(<#= pair.Item1 #> a, <#= pair.Item2 #> b) => a.Value != b;
<#
        }
        else
        {
#>
        /// <param name="a"> <see cref="<#= pair.Item1 #>"/> </param>
        /// <param name="b"> <see cref="<#= pair.Item1 #>"/> </param>
        public static bool operator ==(<#= pair.Item1 #> a, <#= pair.Item1 #> b) => Math.Abs(a.Value - b.Value) <= <#= FLOAT[pair.Item1] #>;

        /// <param name="a"> <see cref="<#= pair.Item1 #>"/> </param>
        /// <param name="b"> <see cref="<#= pair.Item2 #>"/> </param>
        public static bool operator ==(<#= pair.Item1 #> a, <#= pair.Item2 #> b) => Math.Abs(a.Value - b) <= <#= FLOAT[pair.Item1] #>;

        /// <param name="a"> <see cref="<#= pair.Item1 #>"/> </param>
        /// <param name="b"> <see cref="<#= pair.Item1 #>"/> </param>
        public static bool operator !=(<#= pair.Item1 #> a, <#= pair.Item1 #> b) => Math.Abs(a.Value - b.Value) > <#= FLOAT[pair.Item1] #>;

        /// <param name="a"> <see cref="<#= pair.Item1 #>"/> </param>
        /// <param name="b"> <see cref="<#= pair.Item2 #>"/> </param>
        public static bool operator !=(<#= pair.Item1 #> a, <#= pair.Item2 #> b) => Math.Abs(a.Value - b) > <#= FLOAT[pair.Item1] #>;
<#
        }
        if (ADD_SUB.ContainsKey(pair.Item1))
        {
#>
        /// <param name="a"> <see cref="<#= pair.Item1 #>"/> </param>
        /// <param name="b"> <see cref="<#= pair.Item1 #>"/> </param>
        public static <#= pair.Item1 #> operator +(<#= pair.Item1 #> a, <#= pair.Item1 #> b) => new <#= pair.Item1 #>(a.Value + b.Value);

        /// <param name="a"> <see cref="<#= pair.Item1 #>"/> </param>
        /// <param name="b"> <see cref="<#= pair.Item2 #>"/> </param>
        public static <#= pair.Item1 #> operator +(<#= pair.Item1 #> a, <#= pair.Item2 #> b) => new <#= pair.Item1 #>(a.Value + b);

        /// <param name="a"> <see cref="<#= pair.Item1 #>"/> </param>
        /// <param name="b"> <see cref="<#= pair.Item1 #>"/> </param>
        public static <#= pair.Item1 #> operator -(<#= pair.Item1 #> a, <#= pair.Item1 #> b) => new <#= pair.Item1 #>(a.Value - b.Value);

        /// <param name="a"> <see cref="<#= pair.Item1 #>"/> </param>
        /// <param name="b"> <see cref="<#= pair.Item2 #>"/> </param>
        public static <#= pair.Item1 #> operator -(<#= pair.Item1 #> a, <#= pair.Item2 #> b) => new <#= pair.Item1 #>(a.Value - b);
<#
        }
#>
    }
}
<#
        manager.EndBlock();
    }
    manager.Process();
#>
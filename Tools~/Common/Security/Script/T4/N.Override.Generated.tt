<#@ template language="C#" visibility="public" hostspecific="True"
#><#@ assembly name="System.Core"
#><#@ import namespace="System.Collections.Generic"
#><#@ import namespace="System.Linq"
#><#@ include file="Manager.ttinclude"
#><#
    var NUMBER = new List<Tuple<string, string>>
    {
        new("NInt", "int"),
        new("NLong", "long"),
        new("NShort", "short"),
        new("NUInt", "uint"),
        new("NULong", "ulong"),
        new("NUShort", "ushort"),
        new("NBool", "bool"),
        new("NByte", "byte"),
        new("NChar", "char"),
        new("NSByte", "sbyte"),
        new("NString", "string"),
        new("NFloat", "float"),
        new("NDouble", "double"),
        new("NDecimal", "decimal"),
    };
    var ToStringEX = new List<string>
    {
        "NInt",
        "NULong",
        "NLong",
        "NUInt",
        "NUShort",
        "NShort",
        "NByte",
        "NSByte",
        "NFloat",
        "NDouble",
        "NDecimal"
    };
        
    var projectDirectory = Path.GetDirectoryName(Host.TemplateFile);
    var projectFilePath = string.Empty;
    while (!string.IsNullOrEmpty(projectDirectory))
    {
        projectFilePath = Directory.GetFiles(projectDirectory, "*.csproj").FirstOrDefault();
        if (projectFilePath != null) break;
        projectDirectory = Directory.GetParent(projectDirectory)?.FullName;
    }
    
    var manager = new Manager(Host, GenerationEnvironment, "Security");
    manager.OutputPath = Path.Combine(projectDirectory, "Script", "Data");
    manager.StartHeader();
#>
// <auto-generated> This code was generated by a tool. </auto-generated>
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.

using System;
using System.IO;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Threading;
using System.Threading.Tasks;
using System.Globalization;
<#
    manager.EndHeader();
    foreach (var pair in NUMBER)
    {
        manager.StartBlockTemplateName($"{pair.Item1}.Operator.cs", $"{pair.Item1}.cs");
#>

namespace AIO.Security
{
    partial struct <#= pair.Item1 #>
    { 
        /// <inheritdoc/>
        public override bool Equals(object obj) => obj switch
        {
            <#= pair.Item1 #> a => Value.Equals(a.Value),
            <#= pair.Item2 #> b  => Value.Equals(b),
            _       => false
        };

        /// <inheritdoc/>
        public override int GetHashCode() => Value.GetHashCode();

        /// <inheritdoc/>
        public override string ToString() => Value.ToString(CultureInfo.CurrentCulture);

        /// <param name="provider"> 格式化提供者 </param>
        /// <typeparam name="T"> 格式化提供者类型 </typeparam>
        /// <returns> <see cref="string"/> </returns>
        public string ToString<T>(T provider) where T : IFormatProvider => Value.ToString(provider);
<#
        if (ToStringEX.Contains(pair.Item1))
        {
#>

        /// <param name="format"> 格式化字符串 </param>
        /// <returns> <see cref="string"/> </returns>
        public string ToString(string format) => Value.ToString(format, CultureInfo.CurrentCulture);

        /// <param name="format"> 格式化字符串 </param>
        /// <param name="provider"> 格式化提供者 </param>
        /// <typeparam name="T"> 格式化提供者类型 </typeparam>
        /// <returns> <see cref="string"/> </returns>
        public string ToString<T>(string format, T provider) where T : IFormatProvider => Value.ToString(format, provider);
<#
        }
#>
    }
}
<#
        manager.EndBlock();
    }
    manager.Process();
#>
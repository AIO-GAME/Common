using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using UnityEditor;

namespace DG.DemiEditor
{
	public static class DeEditorCoroutines
	{
		private static readonly List<IEnumerator> _Coroutines = new List<IEnumerator>();

		/// <summary>
		/// Starts an editor coroutine. You can't use normal <code>yield new WaitFor</code> methods because
		/// those are Unity runtime, but you can instead use <see cref="M:DG.DemiEditor.DeEditorCoroutines.WaitForSeconds(System.Single)" />.
		/// Other than that, you can use normal <code>yield null/etc</code>.<para />
		/// Returns an <see cref="T:System.Collections.IEnumerator" /> which you can use with <see cref="M:DG.DemiEditor.DeEditorCoroutines.StopCoroutine(System.Collections.IEnumerator)" /> to cancel the coroutine.
		/// </summary>
		public static IEnumerator StartCoroutine(IEnumerator coroutine)
		{
			_Coroutines.Add(coroutine);
			if (_Coroutines.Count == 1)
			{
				EditorApplication.update = (EditorApplication.CallbackFunction)Delegate.Combine(EditorApplication.update, new EditorApplication.CallbackFunction(UpdateCoroutines));
			}
			return coroutine;
		}

		/// <summary>
		/// Stops the given coroutine generated by <see cref="M:DG.DemiEditor.DeEditorCoroutines.StartCoroutine(System.Collections.IEnumerator)" />
		/// </summary>
		public static void StopCoroutine(IEnumerator coroutine)
		{
			bool flag = false;
			for (int i = 0; i < _Coroutines.Count; i++)
			{
				if (_Coroutines[i] == coroutine)
				{
					flag = true;
					_Coroutines.RemoveAt(i);
					break;
				}
			}
			if (flag && _Coroutines.Count == 0)
			{
				EditorApplication.update = (EditorApplication.CallbackFunction)Delegate.Remove(EditorApplication.update, new EditorApplication.CallbackFunction(UpdateCoroutines));
			}
		}

		/// <summary>
		/// To be used inside a coroutine as a yield instruction: waits for the given seconds
		/// (replaces Unity's <code>yield new WaitForSeconds</code> because it's not available in-editor).<para />
		/// Example usage:<para />
		/// <code>yield return DeEditorCoroutines.WaitForSeconds(1);</code>
		/// </summary>
		public static IEnumerator WaitForSeconds(float seconds)
		{
			Stopwatch watch = Stopwatch.StartNew();
			while (watch.Elapsed.TotalSeconds < (double)seconds)
			{
				yield return 0;
			}
		}

		private static void UpdateCoroutines()
		{
			for (int i = 0; i < _Coroutines.Count; i++)
			{
				if ((!(_Coroutines[i].Current is IEnumerator) || !MoveNext((IEnumerator)_Coroutines[i].Current)) && !_Coroutines[i].MoveNext())
				{
					_Coroutines.RemoveAt(i--);
				}
			}
			if (_Coroutines.Count == 0)
			{
				EditorApplication.update = (EditorApplication.CallbackFunction)Delegate.Remove(EditorApplication.update, new EditorApplication.CallbackFunction(UpdateCoroutines));
			}
		}

		private static bool MoveNext(IEnumerator coroutine)
		{
			if (coroutine.Current is IEnumerator coroutine2 && MoveNext(coroutine2))
			{
				return true;
			}
			return coroutine.MoveNext();
		}
	}
}
